
import sched
import time
import random
from packet import *
import GraphManager as GM
#import EventManager2 as EM2
from simpy import *
import simpy as sp
from threading import Timer
from DemandMatrix import *
import DemandMatrix as DemM


class EventManager():

#    def __init__(self):
#        self.scheduler = sched.scheduler(time.time, time.sleep)
#        self.env = env
         # Start the run process everytime an instance is created.
#        self.action = env.process(self.run())
#        self.env = sp.Environment()
#        self.env = env


#     def run(self):
#         while True:
#            print('Start at %d' % self.env.now)
#            charge_duration = 5
#             # We may get interrupted while charging the battery
##             try:
##                 yield self.env.process(self.charge(charge_duration))
##...             except simpy.Interrupt:
##...                 # When we received an interrupt, we stop charging and
##...                 # switch to the "driving" state
##...                 print('Was interrupted. Hope, the battery is full enough ...')
##...
##...             print('Start driving at %d' % self.env.now)
##...             trip_duration = 2             yield self.env.timeout(trip_duration)
#        if()

#    def evaluateDelay(self, nodeA, nodeB, vec_delays)
#        return (vec_delays[indice] / (100 * 100))

    def print_event(self, name, start):
        now = time.time()
        elapsed = int(now - start)
        print('EVENT: {} elapsed={} name={}'.format(time.ctime(now), elapsed, name))


    def DEPARTURE(self,GM, pk, index, DDMM, packetsize):
    #current time
        now = time.time()
        pnow = time.ctime(now)
        sourceID = pk.getsourceID()
        destinationID = pk.getdestinationID()
#        print('time in departure:', time.ctime(now))
#        print("Id packet leaving")
        pkID = pk.getpacketID()
#        print(pk.getpacketID())
#        print("generated by node ")
#        print(pk.getsourceID())
        #update current node
        pk.updateCurrentNode( pk.getnextnodeID())
#        print("leaving from node ")
#        print(pk.getCurrentNode())
        #update info about the packet in GM
#        GM.dellstPackets(pk.getCurrentNode(), pk)
#        #update size of the current node: the packet is leaving
#        GM.updateSizeQueue(pk.getCurrentNode(), -1)
#        print("queue size of ")
#        print(pk.getCurrentNode())
##        print(" is ")
#        print(GM.showSizeQueue(pk.getCurrentNode()))
        flowID = pk.getflowID()
        print("{}-{}\t {} -> {}\t [{}] \t time DEPARTURE: {}".format(pk.getflowID(), pk.getpacketID(), pk.getsourceID(), pk.getdestinationID(), pk.getpath(),  pnow))
        alivepath = pk.getpath()
        alivepk = GM.getalivepk()
#        print('alive packets', alivepk)
        GM.delalivepk(pk.getflowID(), pk.getpacketID())
        alivepk = GM.getalivepk()
#        print('alive packets', alivepk)
        countpk = 0
#        print('alivepath', alivepath[:-2])
        for id in alivepk:
            if(id[0] == flowID):
                countpk += 1
        if(countpk == 0):
            GM.delaliveflow(flowID)
            GM.delalivePaths(alivepath[:-2])
#        print('countpk', countpk)
        DM = DDMM.updateDemandMatrix(sourceID, destinationID, packetsize, -1)



#        if(GM.showSizeQueue(pk.getCurrentNode()) >= 1): #serve the next packet in the queue
#            #if(pk.getDeparturetime == CurrentTime):
#            #if (GM.getSizeQueue() >= 1):
#
#            serviceTime = 60#exponential(1)
##            self.scheduler.enter(serviceTime, 1, self.DEPARTURE, (GM, nodeID, GM.getfirstpacket(nodeID)))



#    def ARRIVAL(self, GM, pk, destinationID):
#    #update size queue node
#    #update packet info in that node
#    #    if(Topology[n].getSizeQueue() == 1) serve that packet in the queue
#        now = time.time()
#        print('time in arrival:', time.ctime(now))
#        print("Id packet arriving")
#        print(pk.getpacketID())
#        print("generated by node ")
#        print(pk.getsourceID())
#        print("to node ")
#        print(pk.getCurrentNode()) #modify!!!!!!
#        GM.updateSizeQueue(destinationID, 1)
##        print("queue size in ")
##        print(destinationID)
##        print(" is ")
##        print(GM.showSizeQueue(destinationID))
###IF DESTINATION IS THE FINAL DESTINATION, CALL DEPARTURE
###ELSE CALL MIGRATE AND CHOOSE THE DESTINATION WITH THE FUNZTION IMPLEMENTED
#        if(GM.showSizeQueue(destinationID) == 1): #serve that packet in the queue
#            serviceTime = 60#exponential(1)
##scheduler.enter(delay, priority, action, argument=(), kwargs={})
#            self.scheduler.enter(serviceTime, 1, self.DEPARTURE, (GM, destinationID, pk))

    def MIGRATE(self, GM, newpk, index, DDMM, packetsize):
        #current time
        now = time.time()
        pnow = time.ctime(now)
#        print('time MIGRATION:', time.ctime(now))
        #when the migration occurs, the packet moves from currentNode to nextNode
        #therefore, the queue size of currentNode decreases
        GM.updateSizeQueue(newpk.getCurrentNode(), -1)
        #update packet and oldnode information in GM
        GM.dellstPackets(newpk.getCurrentNode(), newpk)
#        print("previous node")
#        print(newpk.getCurrentNode())
        #nextNode is the new current node
        currentNode = newpk.getnextnodeID()
#        print("current node")
#        print(currentNode)
        #the queue size of the new currentNode increase
        GM.updateSizeQueue(currentNode, 1)
        #update packet and currentnode information in GM
        GM.updatelstPackets(currentNode, newpk)
        #update new current node of the packet
        newpk.updateCurrentNode( newpk.getnextnodeID())
        #update new nextnode
        path = newpk.getpath()
#        print("path")
#        print(path)
#        print('index', index)
        newindex = index+1
        newNextNode = path[newindex]
        newpk.updateNextNode(newpk.getpacketID(), newNextNode)
        
#        print("sourceID")
#        print(newpk.getsourceID())
#        print("destination")
#        print(newpk.getdestinationID())
#        print("pkID")
#        print(newpk.getpacketID())
#        print('next node', newNextNode)
#        print("current node queue size", GM.showSizeQueue(currentNode))
        print("{}-{}\t {} -> {}\t [{}] -> {} \t time MIGRATION: {}".format(newpk.getflowID(), newpk.getpacketID(), newpk.getsourceID(), newpk.getdestinationID(), path, newNextNode, pnow))
        nodeA = currentNode
        if(newNextNode < currentNode):
            nodeA = newNextNode
            nodeB = currentNode
        else:
            nodeB = newNextNode

        transmissionTime = random.uniform(1, 3)#GM.getDelayEdges(nodeA, nodeB)#30#evaluateDelay()


#        pk.removePacket(packetID)
        if(GM.showSizeQueue(currentNode) >= 1): #serve the next packet in the queue

            if(newNextNode == newpk.getdestinationID()):
                Timer(transmissionTime, self.DEPARTURE, (GM, newpk, newindex, DDMM, packetsize)).start()
            else:
                Timer(transmissionTime, self.MIGRATE, (GM, newpk, newindex, DDMM, packetsize)).start()


#update size queue node
#update packet info in that node
    def GENERATE(self, GM, newpk, DDMM, packetsize):
        """
            event called when a new packet is generated. It triggers
            - a migration event if the next node is not the destination
            - a departure event if the next node is the destination
            one of this two events will occur after a specific time interval. This time interval = elaboration time + transmission time from the current node to the next node
            Args:
            GM =
            newpk =
            Returns:

            """
#        print("generate")
    #    if(Topology[n].getSizeQueue() == 1) serve that packet in the queue
        now = time.time()
        pnow = time.ctime(now)
#        print("Id packet arriving")
#        print(pk.getpacketID())

        pkID = newpk.getpacketID()
        sourceID = newpk.getsourceID()
        destinationID = newpk.getdestinationID()
        path = newpk.getpath()
        nextnodeID = path[1]
        newpk.updateNextNode(pkID, nextnodeID)
        print("{}-{}\t {} -> {}\t [{}] -> {} \t time GENERATION: {}".format(newpk.getflowID(), pkID, sourceID, destinationID, path, newpk.getnextnodeID(), pnow))


#        newpk = packet(pkID, sourceID , destinationID)
        GM.updatelstPackets(sourceID, newpk)
        index = 1
        
        GM.updateSizeQueue(sourceID, 1)
        nodeA = sourceID
        if(nextnodeID < sourceID):
            nodeA = nextnodeID
            nodeB = sourceID
        else:
            nodeB = nextnodeID
        transmissionTime = random.uniform(1, 3)#GM.getDelayEdges(nodeA, nodeB)#30#evaluateDelay()
#        print('size', GM.showSizeQueue(newpk.getCurrentNode()))
#        #when the packet arrive to the first desitation nodenode
#        self.scheduler.enter(transmissionTime, 1, self.ARRIVAL, (GM, newpk, destinationID))
        if(GM.showSizeQueue(newpk.getCurrentNode()) >= 1): #serve that packet in the queue
#            print('len path', len(path))
            if(index < len(path)-3):
#                print("migrate from gen")
                serviceTime = 60#exponential(1)
                tempo = transmissionTime+pkID

                print('migrazione dopo ', tempo)

                Timer(tempo, self.MIGRATE, (GM, newpk, index, DDMM, packetsize)).start()
            else:
                tempo = transmissionTime+pkID

                Timer(tempo, self.DEPARTURE, (GM, newpk, index, DDMM, packetsize)).start()



#devo considerare ogni volta il nodo successivo
#per trovare il percorso del pacchetto successivo devo considerare i percorsi dei pacchetti ancora nel sistema

                generationTime = 1#exponential(1)



#scheduler.enter(2, 1, print_event, ('second', start))
#EVENT: Sun Sep  4 16:21:04 2016 elapsed=3 name=second

    def schedulerRun(self):
        self.scheduler.run()
    def envRun(self, time):
        self.env.run(until=time)

    def END(self):
        print('end')
        sys.exit()




